<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VLM Trade Chart</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1a2e;
      overflow: hidden;
    }

    #chart-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .pane {
      position: relative;
      width: 100%;
      overflow: hidden;
    }

    .pane-title {
      position: absolute;
      left: 12px;
      top: 8px;
      z-index: 10;
      font-family: Arial, sans-serif;
      font-size: 12px;
      color: rgba(224, 224, 224, 0.85);
      background: rgba(15, 15, 25, 0.55);
      padding: 3px 8px;
      border-radius: 6px;
      pointer-events: none;
      letter-spacing: 0.3px;
    }
  </style>
</head>

<body>
  <div id="chart-container">
    <div id="main-pane" class="pane">
      <div class="pane-title">主图 · BOLL(20, 2)</div>
    </div>
    <div id="volume-pane" class="pane">
      <div class="pane-title">成交量</div>
    </div>
    <div id="macd-pane" class="pane">
      <div class="pane-title">MACD(12, 26, 9)</div>
    </div>
    <div id="trend-strength-pane" class="pane">
      <div class="pane-title">趋势强度 · ADX(14)</div>
    </div>
  </div>

  <script id="chart-config" type="application/json">
    { "width": {{ WIDTH }}, "height": {{ HEIGHT }}, "volumeHeight": {{ VOLUME_HEIGHT }}, "macdHeight": {{ MACD_HEIGHT }}, "trendStrengthHeight": {{ TREND_STRENGTH_HEIGHT }} }
  </script>
  <script id="chart-data" type="application/json">{{ CHART_DATA }}</script>
  <script id="chart-overlays" type="application/json">{{ OVERLAYS }}</script>
  <script id="chart-watermark" type="application/json">{{ WATERMARK_JSON }}</script>

  <script>
    // @ts-nocheck
    function readJsonFromScriptTag(scriptId, fallbackValue) {
      const element = document.getElementById(scriptId);
      if (!element) return fallbackValue;

      const rawText = (element.textContent || '').trim();
      if (!rawText) return fallbackValue;

      try {
        return JSON.parse(rawText);
      } catch (error) {
        console.warn('解析 JSON 失败:', scriptId, error);
        return fallbackValue;
      }
    }

    function normalizeChartConfig(rawConfig) {
      const width = Number(rawConfig?.width);
      const height = Number(rawConfig?.height);
      const volumeHeight = Number(rawConfig?.volumeHeight);
      const macdHeight = Number(rawConfig?.macdHeight);
      const trendStrengthHeight = Number(rawConfig?.trendStrengthHeight);

      const normalizedWidth = Number.isFinite(width) && width > 0 ? width : 1280;
      const normalizedHeight = Number.isFinite(height) && height > 0 ? height : 720;
      const clampRatio = (v, fallback) =>
        Number.isFinite(v) && v >= 0 && v < 1 ? v : fallback;

      let normalizedVolumeHeight = clampRatio(volumeHeight, 0.2);
      let normalizedMacdHeight = clampRatio(macdHeight, 0.15);
      let normalizedTrendStrengthHeight = clampRatio(trendStrengthHeight, 0.15);

      // 保证主图区至少占 35%，不足则整体缩小子图比例
      const maxSubSum = 0.65;
      const subSum = normalizedVolumeHeight + normalizedMacdHeight + normalizedTrendStrengthHeight;
      if (subSum > maxSubSum && subSum > 0) {
        const scale = maxSubSum / subSum;
        normalizedVolumeHeight *= scale;
        normalizedMacdHeight *= scale;
        normalizedTrendStrengthHeight *= scale;
      }

      return {
        width: normalizedWidth,
        height: normalizedHeight,
        volumeHeight: normalizedVolumeHeight,
        macdHeight: normalizedMacdHeight,
        trendStrengthHeight: normalizedTrendStrengthHeight,
      };
    }

    // 图表数据将通过 Puppeteer 注入
    window.chartConfig = normalizeChartConfig(readJsonFromScriptTag('chart-config', {}));
    window.chartData = readJsonFromScriptTag('chart-data', []);
    window.overlays = readJsonFromScriptTag('chart-overlays', []);
    window.watermark = readJsonFromScriptTag('chart-watermark', '');

    function initChart() {
      const container = document.getElementById('chart-container');
      const mainPane = document.getElementById('main-pane');
      const volumePane = document.getElementById('volume-pane');
      const macdPane = document.getElementById('macd-pane');
      const trendStrengthPane = document.getElementById('trend-strength-pane');
      const config = window.chartConfig;

      const mainHeight = Math.floor(config.height * (1 - config.volumeHeight - config.macdHeight - config.trendStrengthHeight));
      const volumeHeightPx = Math.floor(config.height * config.volumeHeight);
      const macdHeightPx = Math.floor(config.height * config.macdHeight);
      const trendStrengthHeightPx = Math.floor(config.height * config.trendStrengthHeight);

      container.style.width = config.width + 'px';
      container.style.height = config.height + 'px';
      mainPane.style.height = mainHeight + 'px';
      volumePane.style.height = volumeHeightPx + 'px';
      macdPane.style.height = macdHeightPx + 'px';
      trendStrengthPane.style.height = trendStrengthHeightPx + 'px';

      // 创建主图表
      const chart = LightweightCharts.createChart(mainPane, {
        width: config.width,
        height: mainHeight,
        layout: {
          background: { type: 'solid', color: '#1a1a2e' },
          textColor: '#e0e0e0',
          fontSize: 12,
        },
        grid: {
          vertLines: { color: '#2a2a4a' },
          horzLines: { color: '#2a2a4a' },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
          borderColor: '#2a2a4a',
        },
        timeScale: {
          borderColor: '#2a2a4a',
          timeVisible: true,
          secondsVisible: false,
        },
        watermark: {
          visible: true,
          fontSize: 48,
          horzAlign: 'center',
          vertAlign: 'center',
          color: 'rgba(255, 255, 255, 0.1)',
          text: window.watermark,
        },
      });

      // 蜡烛图系列
      const candleSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        borderUpColor: '#26a69a',
        borderDownColor: '#ef5350',
      });

      const data = window.chartData.map(bar => ({
        time: bar.time,
        open: bar.open,
        high: bar.high,
        low: bar.low,
        close: bar.close,
      }));
      candleSeries.setData(data);

      // 指标计算（渲染在截图 PNG 内）
      const closes = window.chartData.map(b => b.close);
      const highs = window.chartData.map(b => b.high);
      const lows = window.chartData.map(b => b.low);

      function sma(values, period) {
        const result = new Array(values.length).fill(null);
        if (!values.length || period <= 0) return result;
        let sum = 0;
        for (let i = 0; i < values.length; i++) {
          sum += values[i];
          if (i >= period) sum -= values[i - period];
          if (i >= period - 1) result[i] = sum / period;
        }
        return result;
      }

      function std(values, period, mean) {
        const result = new Array(values.length).fill(null);
        if (!values.length || period <= 0) return result;

        for (let i = period - 1; i < values.length; i++) {
          let acc = 0;
          for (let j = i - period + 1; j <= i; j++) {
            const d = values[j] - mean[i];
            acc += d * d;
          }
          result[i] = Math.sqrt(acc / period);
        }
        return result;
      }

      function ema(values, period) {
        const result = new Array(values.length).fill(null);
        if (!values.length || period <= 0) return result;

        const alpha = 2 / (period + 1);
        let prev = null;

        for (let i = 0; i < values.length; i++) {
          const v = values[i];
          if (prev === null) {
            if (i >= period - 1) {
              const seed = values.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0) / period;
              prev = seed;
              result[i] = prev;
            }
            continue;
          }
          prev = alpha * v + (1 - alpha) * prev;
          result[i] = prev;
        }

        return result;
      }

      function computeBollinger(values, period, mult) {
        const middle = sma(values, period);
        const deviation = std(values, period, middle);
        const upper = middle.map((m, i) => (m == null || deviation[i] == null ? null : m + mult * deviation[i]));
        const lower = middle.map((m, i) => (m == null || deviation[i] == null ? null : m - mult * deviation[i]));
        return { upper, middle, lower };
      }

      function computeMACD(values, fast, slow, signalPeriod) {
        const fastEma = ema(values, fast);
        const slowEma = ema(values, slow);
        const macd = values.map((_, i) => (fastEma[i] == null || slowEma[i] == null ? null : fastEma[i] - slowEma[i]));
        const signal = ema(macd.map(v => (v == null ? 0 : v)), signalPeriod);
        const hist = macd.map((m, i) => (m == null || signal[i] == null ? null : m - signal[i]));
        return { macd, signal, hist };
      }

      function computeADX(high, low, close, period) {
        const len = close.length;
        const tr = new Array(len).fill(null);
        const plusDM = new Array(len).fill(null);
        const minusDM = new Array(len).fill(null);

        for (let i = 1; i < len; i++) {
          const upMove = high[i] - high[i - 1];
          const downMove = low[i - 1] - low[i];

          plusDM[i] = upMove > downMove && upMove > 0 ? upMove : 0;
          minusDM[i] = downMove > upMove && downMove > 0 ? downMove : 0;

          const range1 = high[i] - low[i];
          const range2 = Math.abs(high[i] - close[i - 1]);
          const range3 = Math.abs(low[i] - close[i - 1]);
          tr[i] = Math.max(range1, range2, range3);
        }

        const smoothTR = new Array(len).fill(null);
        const smoothPlusDM = new Array(len).fill(null);
        const smoothMinusDM = new Array(len).fill(null);

        let trSum = 0;
        let plusSum = 0;
        let minusSum = 0;

        for (let i = 1; i < len; i++) {
          trSum += tr[i] ?? 0;
          plusSum += plusDM[i] ?? 0;
          minusSum += minusDM[i] ?? 0;

          if (i === period) {
            smoothTR[i] = trSum;
            smoothPlusDM[i] = plusSum;
            smoothMinusDM[i] = minusSum;
          } else if (i > period) {
            smoothTR[i] = (smoothTR[i - 1] ?? 0) - (smoothTR[i - 1] ?? 0) / period + (tr[i] ?? 0);
            smoothPlusDM[i] = (smoothPlusDM[i - 1] ?? 0) - (smoothPlusDM[i - 1] ?? 0) / period + (plusDM[i] ?? 0);
            smoothMinusDM[i] = (smoothMinusDM[i - 1] ?? 0) - (smoothMinusDM[i - 1] ?? 0) / period + (minusDM[i] ?? 0);
          }
        }

        const plusDI = new Array(len).fill(null);
        const minusDI = new Array(len).fill(null);
        const dx = new Array(len).fill(null);

        for (let i = period; i < len; i++) {
          const trVal = smoothTR[i];
          if (!trVal || trVal === 0) continue;

          const p = 100 * (smoothPlusDM[i] / trVal);
          const m = 100 * (smoothMinusDM[i] / trVal);
          plusDI[i] = Number.isFinite(p) ? p : null;
          minusDI[i] = Number.isFinite(m) ? m : null;

          const denom = (plusDI[i] ?? 0) + (minusDI[i] ?? 0);
          if (denom === 0) continue;
          dx[i] = 100 * Math.abs((plusDI[i] - minusDI[i]) / denom);
        }

        const adx = new Array(len).fill(null);
        let adxSeedSum = 0;
        let adxSeedCount = 0;
        for (let i = period; i < len; i++) {
          if (dx[i] == null) continue;
          adxSeedSum += dx[i];
          adxSeedCount++;
          if (adxSeedCount === period) {
            adx[i] = adxSeedSum / period;
            break;
          }
        }

        for (let i = 0; i < len; i++) {
          if (adx[i] != null) {
            for (let j = i + 1; j < len; j++) {
              if (dx[j] == null) continue;
              adx[j] = ((adx[j - 1] ?? 0) * (period - 1) + dx[j]) / period;
            }
            break;
          }
        }

        return { adx, plusDI, minusDI };
      }

      // BOLL 叠加在主图
      const boll = computeBollinger(closes, 20, 2);
      const bollUpperSeries = chart.addLineSeries({ color: 'rgba(255, 193, 7, 0.9)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
      const bollMiddleSeries = chart.addLineSeries({ color: 'rgba(255, 193, 7, 0.55)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
      const bollLowerSeries = chart.addLineSeries({ color: 'rgba(255, 193, 7, 0.9)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });

      const upperData = data.map((d, i) => (boll.upper[i] == null ? null : ({ time: d.time, value: boll.upper[i] }))).filter(Boolean);
      const middleData = data.map((d, i) => (boll.middle[i] == null ? null : ({ time: d.time, value: boll.middle[i] }))).filter(Boolean);
      const lowerData = data.map((d, i) => (boll.lower[i] == null ? null : ({ time: d.time, value: boll.lower[i] }))).filter(Boolean);
      bollUpperSeries.setData(upperData);
      bollMiddleSeries.setData(middleData);
      bollLowerSeries.setData(lowerData);

      const volumeChart = LightweightCharts.createChart(volumePane, {
        width: config.width,
        height: volumeHeightPx,
        layout: {
          background: { type: 'solid', color: '#1a1a2e' },
          textColor: '#e0e0e0',
        },
        grid: {
          vertLines: { color: '#2a2a4a' },
          horzLines: { color: '#2a2a4a' },
        },
        rightPriceScale: {
          borderColor: '#2a2a4a',
        },
        timeScale: {
          visible: false,
        },
      });

      const volumeSeries = volumeChart.addHistogramSeries({
        color: 'rgba(38, 166, 154, 0.5)',
        priceFormat: { type: 'volume' },
        priceScaleId: '',
      });

      const volumeData = window.chartData.map(bar => ({
        time: bar.time,
        value: bar.volume,
        color: bar.close >= bar.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)',
      }));
      volumeSeries.setData(volumeData);

      // MACD 子图
      const macdChart = LightweightCharts.createChart(macdPane, {
        width: config.width,
        height: macdHeightPx,
        layout: {
          background: { type: 'solid', color: '#1a1a2e' },
          textColor: '#e0e0e0',
          fontSize: 11,
        },
        grid: {
          vertLines: { color: '#2a2a4a' },
          horzLines: { color: '#2a2a4a' },
        },
        rightPriceScale: { borderColor: '#2a2a4a' },
        timeScale: { visible: false },
      });

      const macdSeries = macdChart.addLineSeries({ color: 'rgba(59, 130, 246, 0.95)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
      const signalSeries = macdChart.addLineSeries({ color: 'rgba(236, 72, 153, 0.9)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
      const histSeries = macdChart.addHistogramSeries({ priceLineVisible: false, lastValueVisible: false });

      const macd = computeMACD(closes, 12, 26, 9);
      macdSeries.setData(data.map((d, i) => (macd.macd[i] == null ? null : ({ time: d.time, value: macd.macd[i] }))).filter(Boolean));
      signalSeries.setData(data.map((d, i) => (macd.signal[i] == null ? null : ({ time: d.time, value: macd.signal[i] }))).filter(Boolean));
      histSeries.setData(data.map((d, i) => {
        const v = macd.hist[i];
        if (v == null) return null;
        return { time: d.time, value: v, color: v >= 0 ? 'rgba(38, 166, 154, 0.55)' : 'rgba(239, 83, 80, 0.55)' };
      }).filter(Boolean));

      // 趋势强度(ADX) 子图
      const strengthChart = LightweightCharts.createChart(trendStrengthPane, {
        width: config.width,
        height: trendStrengthHeightPx,
        layout: {
          background: { type: 'solid', color: '#1a1a2e' },
          textColor: '#e0e0e0',
          fontSize: 11,
        },
        grid: {
          vertLines: { color: '#2a2a4a' },
          horzLines: { color: '#2a2a4a' },
        },
        rightPriceScale: { borderColor: '#2a2a4a' },
        timeScale: { visible: false },
      });

      const adxSeries = strengthChart.addLineSeries({ color: 'rgba(168, 85, 247, 0.95)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
      const adx = computeADX(highs, lows, closes, 14);
      adxSeries.setData(data.map((d, i) => (adx.adx[i] == null ? null : ({ time: d.time, value: adx.adx[i] }))).filter(Boolean));

      // 同步时间轴
      chart.timeScale().subscribeVisibleTimeRangeChange(() => {
        const range = chart.timeScale().getVisibleRange();
        if (range) {
          volumeChart.timeScale().setVisibleRange(range);
          macdChart.timeScale().setVisibleRange(range);
          strengthChart.timeScale().setVisibleRange(range);
        }
      });

      // 应用标注
      applyOverlays(chart, candleSeries);

      // 设置可见范围，右侧预留5根K线的空间
      const totalBars = data.length;
      if (totalBars > 0) {
        const rightPadding = 5; // 右侧预留的K线数量
        const visibleTo = totalBars - 1;
        const visibleFrom = 0;
        
        chart.timeScale().setVisibleLogicalRange({
          from: visibleFrom - 0.5,
          to: visibleTo + rightPadding
        });
        
        volumeChart.timeScale().setVisibleLogicalRange({
          from: visibleFrom - 0.5,
          to: visibleTo + rightPadding
        });

        macdChart.timeScale().setVisibleLogicalRange({
          from: visibleFrom - 0.5,
          to: visibleTo + rightPadding
        });

        strengthChart.timeScale().setVisibleLogicalRange({
          from: visibleFrom - 0.5,
          to: visibleTo + rightPadding
        });
      } else {
        // 数据为空时使用默认行为
        chart.timeScale().fitContent();
        volumeChart.timeScale().fitContent();
        macdChart.timeScale().fitContent();
        strengthChart.timeScale().fitContent();
      }

      window.mainChart = chart;
      window.candleSeries = candleSeries;
      window.__chartReady = true;
    }

    function applyOverlays(chart, candleSeries) {
      const overlays = window.overlays || [];
      const data = window.chartData;

      for (const overlay of overlays) {
        try {
          if (overlay.type === 'horizontal_line') {
            applyHorizontalLine(chart, overlay, data);
          } else if (overlay.type === 'trend_line') {
            applyTrendLine(chart, overlay, data);
          } else if (overlay.type === 'polyline') {
            applyPolyline(chart, overlay, data);
          } else if (overlay.type === 'marker') {
            applyMarker(candleSeries, overlay, data);
          } else if (overlay.type === 'label') {
            applyLabel(candleSeries, overlay, data);
          } else if (overlay.type === 'parallel_channel') {
            applyParallelChannel(chart, overlay, data);
          } else if (overlay.type === 'ray_line') {
            applyRayLine(chart, overlay, data);
          }
        } catch (e) {
          console.error('应用标注失败:', overlay, e);
        }
      }
    }

    function applyHorizontalLine(chart, overlay, data) {
      if (overlay.price == null || !data.length) return;

      const lineSeries = chart.addLineSeries({
        color: overlay.color || '#ffffff',
        lineWidth: overlay.width || 2,
        priceLineVisible: true,
        lastValueVisible: true,
      });

      const startTime = data[0].time;
      const endTime = data[data.length - 1].time;

      lineSeries.setData([
        { time: startTime, value: overlay.price },
        { time: endTime, value: overlay.price },
      ]);
    }

    function applyTrendLine(chart, overlay, data) {
      if (!overlay.start || !overlay.end || !data.length) return;

      const startBarIndex = overlay.start.barIndex;
      const endBarIndex = overlay.end.barIndex;

      if (startBarIndex == null || endBarIndex == null) return;
      if (startBarIndex < 0 || startBarIndex >= data.length) return;
      if (endBarIndex < 0 || endBarIndex >= data.length) return;

      const lineSeries = chart.addLineSeries({
        color: overlay.color || '#ffffff',
        lineWidth: overlay.width || 2,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      lineSeries.setData([
        { time: data[startBarIndex].time, value: overlay.start.price },
        { time: data[endBarIndex].time, value: overlay.end.price },
      ]);
    }

    function applyPolyline(chart, overlay, data) {
      if (!overlay.points || overlay.points.length < 2 || !data.length) return;

      const lineData = [];
      for (const point of overlay.points) {
        const barIndex = point.barIndex;
        if (barIndex == null || barIndex < 0 || barIndex >= data.length) continue;

        lineData.push({
          time: data[barIndex].time,
          value: point.price
        });
      }

      if (lineData.length < 2) return;

      const lineSeries = chart.addLineSeries({
        color: overlay.color || '#ffffff',
        lineWidth: overlay.width || 2,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      lineSeries.setData(lineData);
    }

    function applyParallelChannel(chart, overlay, data) {
      if (!overlay.start || !overlay.end || !data.length) return;

      const startBarIndex = overlay.start.barIndex;
      const endBarIndex = overlay.end.barIndex;
      const channelWidth = overlay.channelWidth || 0;

      if (startBarIndex == null || endBarIndex == null) return;
      if (startBarIndex < 0 || startBarIndex >= data.length) return;
      if (endBarIndex < 0 || endBarIndex >= data.length) return;

      const color = overlay.color || '#ffffff';
      const width = overlay.width || 2;

      // 主线
      const line1 = chart.addLineSeries({
        color, lineWidth: width, priceLineVisible: false, lastValueVisible: false,
      });
      line1.setData([
        { time: data[startBarIndex].time, value: overlay.start.price },
        { time: data[endBarIndex].time, value: overlay.end.price },
      ]);

      // 平行线
      const line2 = chart.addLineSeries({
        color, lineWidth: width, priceLineVisible: false, lastValueVisible: false,
      });
      line2.setData([
        { time: data[startBarIndex].time, value: overlay.start.price + channelWidth },
        { time: data[endBarIndex].time, value: overlay.end.price + channelWidth },
      ]);
    }

    function applyRayLine(chart, overlay, data) {
      if (!overlay.start || !data.length) return;

      const startBarIndex = overlay.start.barIndex;
      if (startBarIndex == null || startBarIndex < 0 || startBarIndex >= data.length) return;

      const lineSeries = chart.addLineSeries({
        color: overlay.color || '#ffffff',
        lineWidth: overlay.width || 2,
        priceLineVisible: false,
        lastValueVisible: false,
      });

      lineSeries.setData([
        { time: data[startBarIndex].time, value: overlay.start.price },
        { time: data[data.length - 1].time, value: overlay.start.price },
      ]);
    }

    function applyMarker(candleSeries, overlay, data) {
      if (!overlay.start) return;

      const barIndex = overlay.start.barIndex;
      if (barIndex == null || barIndex < 0 || barIndex >= data.length) return;

      const shapeMap = {
        arrow_up: 'arrowUp',
        arrow_down: 'arrowDown',
        circle: 'circle',
        square: 'square',
      };

      const positionMap = {
        above_bar: 'aboveBar',
        below_bar: 'belowBar',
        inside_bar: 'inBar',
      };

      candleSeries.setMarkers([
        ...candleSeries.markers ? candleSeries.markers() : [],
        {
          time: data[barIndex].time,
          position: positionMap[overlay.position] || 'belowBar',
          shape: shapeMap[overlay.shape] || 'arrowUp',
          color: overlay.color || '#ffffff',
          text: overlay.text || '',
        },
      ]);
    }

    function applyLabel(candleSeries, overlay, data) {
      if (!overlay.start) return;

      const barIndex = overlay.start.barIndex;
      if (barIndex == null || barIndex < 0 || barIndex >= data.length) return;

      // Label 使用 marker 实现，但用 circle 形状且显示文本
      candleSeries.setMarkers([
        ...candleSeries.markers ? candleSeries.markers() : [],
        {
          time: data[barIndex].time,
          position: 'aboveBar',
          shape: 'circle',
          color: overlay.color || '#ffffff',
          text: overlay.text || '',
        },
      ]);
    }

    // 由 Node 侧在 lightweight-charts 注入完成后调用
    window.__initChart = initChart;
  </script>
</body>

</html>
